
import os
import argparse

formattingHelp = """
Autogenerated EA definitions by Snek: Designed for building lists of unique custom definitions.
Usage:
    Script format:
        (Definition) (Optional value)
        If no optional value is provided, the definition will be considered "implicit", equaling the previous + 1.
        .include (Any number of relative filepaths) will start reading from the new script.
            Each new script begins its own numbering scheme. A new script does NOT follow its parent's scheme.
        .avoid (Value) (Optional larger value) will define values autogenerated definitions will avoid.
            A single value will just avoid that one.
            Two values will avoid the entire range of values between them as well as those values inclusive.
            Avoids only apply to the immediate file in which they are declared for definitions following them.
        .ceiling (Value) will cap definitions at that value.
        @ or // Denote the rest of the line as a comment.
"""

defaultExtra = 'Use --formatting for formatting help.'

args = []

class Error(Exception):
    def __init__(self,message):
        if ( args.clean ):
            try:
                os.remove(args.output)
            except FileNotFoundError:
                pass
        super().__init__(message)

class NoIncludedFileError(Error):
    """Raised when an included file does not exist"""
    def __init__(self,missingFile,filename=None,line=-1,extra=defaultExtra):
        if filename:
            super().__init__(f'Error in {filename} at line {line}: File {missingFile} not found.\n{extra}')
        else:
            super().__init__(f'Error: File {missingFile} not found.\n')

class IncorrectArgumentNumberError(Error):
    """Raised when something has the wrong number of arguments"""
    def __init__(self,file=None,line=-1,extra=defaultExtra):
        if file:
            super().__init__(f'Error in {file} at line {line}: Incorrect number of arguments.\n{extra}')
        else:
            super().__init__(f'Error: Incorrect number of arguments.\n{extra}')

class InvalidArgumentError(Error):
    """Raised when some argument is invalid"""
    def __init__(self,file,line,extra=defaultExtra):
        super().__init__(f'Error in {file} at line {line}: Invalid parameter.\n{extra}')


def cleanUpRangeList(list):
    # list is a list of 2-length lists which represent ranges of values. We're going to return a new sorted list with condensed, sorted ranges.
    nums = [] # Sorted list of numbers to avoid. Will be useful in re-generating ranges.
    new = [] # This will be our new list of 2-length lists.
    for e in list:
        for n in range(e[0],e[1]+1):
            if not n in nums: nums.append(n)
    nums = sorted(nums)
    # Time to generate ranges.
    i = 0
    while i < len(nums):
        j = i
        while ( j+1 < len(nums) and nums[j]+1 == nums[j+1] ):
            j += 1
        new.append([nums[i],nums[j]])
        i = j+1
    return new

def addToAvoid(avoid,vals):
    # Avoid is a list of ranges to avoid. vals is a 1 or 2 length list.
    if ( len(vals) == 1 ): vals.append(vals[0]) # Let's treat a single value as a range from that value to that value.
    avoid.append(vals)
    return cleanUpRangeList(avoid) # Let's just let the cleanup function handle optimization of the list.

def handleAvoidedValues(val,avoid):
    # Returns the next not avoided incremental value. Avoid is assumed to be a neat list of 2-length ordered lists of ranges to avoid.
    for e in avoid:
        if ( val >= e[0] and val <= e[1] ):
            return e[1]+1
    return val

def ext(file,parent,parentLine=0):
    defs = []
    avoid = [] # List of lists representing values to avoid. A single number avoids just that, and two numbers avoids the range between them inclusive.
    ceiling = -1
    definition = 0
    
    for lineNumber, line in enumerate(file,1):
        line = line.strip()
        if ( line.find('//') != -1 ):
            line = line[:line.find('//')]
        if ( line.find('@') != -1 ):
            line = line[:line.find('@')]
        splitted = line.split() # This is a list representing the string split up by whitespace.
        
        if ( len(splitted) == 0 ):
            continue # This line is just whitespace. Ignore it.
        else:
            
            # We need to check if they're including another file.
            if ( splitted[0] == '.include' ):
                if ( len(splitted) > 1 ):
                    for external in splitted[1:]:
                        try:
                            with open(external,'r') as extf:
                                defs = defs + ext(extf,file,lineNumber)
                        except FileNotFoundError:
                            raise NoIncludedFileError(external,file.name,lineNumber)
                    continue
                else:
                    raise IncorrectArgumentNumberError(file.name,lineNumber)
            
            # We need to check if they're declaring values to avoid.
            if ( splitted[0] == '.avoid' ):
                if ( len(splitted) == 2 or len(splitted) == 3 ):
                    avoid = addToAvoid(avoid,[int(splitted[1],0),int(splitted[-1],0)])
                    continue
                else:
                    raise IncorrectArgumentNumberError(file,lineNumber)
            
            if ( splitted[0] == '.ceiling' ):
                if ( len(splitted) == 2 ):
                    try:
                        if ceiling < 0 or int(splitted[1],0) < ceiling: ceiling = int(splitted[1],0)
                        continue
                    except ValueError:
                        raise InvalidArgumentError(file.name,lineNumber,extra='Ceiling value must be an int.')
                else:
                    raise IncorrectArgumentNumberError(file.name,lineNumber)
            
            elif ( len(splitted) == 1 ):
                # "Implicit" definition. We want our definition to equal the previous incremented by 1.
                # definition should still contain the previous one's definition.
                definition = handleAvoidedValues(definition+1,avoid)
            
            elif ( len(splitted) == 2 ):
                # "Explicit" definition. Use the definition that they've used.
                try:
                    definition = int(splitted[1],0)
                    # If the value isn't avoided, then the returned value should be the same as what's passed in.
                    if ( handleAvoidedValues(definition,avoid) != definition ):
                        raise InvalidArgumentError(file.name,lineNumber,extra='Explicit definition in an area being avoided.')
                except ValueError:
                    raise InvalidArgumentError(file.name,lineNumber,extra='Explicit definition value must be a number.')
            
            else:
                raise IncorrectArgumentNumberError(file.name,lineNumber)
            
            # Is our definition greater than our ceiling?
            if ceiling >= 0 and definition > ceiling: definition = ceiling
            
            defs.append(f'#define {splitted[0]} 0x{definition:0X}')
    return defs

parser = argparse.ArgumentParser()
parser.add_argument('input',help='Filepath for input definition script to run.',type=argparse.FileType('r'))
parser.add_argument('output',help='Filepath for desired output EA script.')
parser.add_argument('-c','--clean',help='Delete output file/produce no output with an error.',action='store_true')
parser.add_argument('-f','--formatting',action='store_true',help='Show a formatting help message.')
args = parser.parse_args()

if args.formatting: exit(formattingHelp)

try:
    final = ext(args.input,'__main__')
    output = open(args.output,'w')
    output.write('\n'.join(final))
    output.close()
except Error as e:
    print(e)
    exit()
